{"remainingRequest":"/home/david/workspace/kalendar/node_modules/vue-loader/lib/index.js??vue-loader-options!/home/david/workspace/kalendar/src/components/kalendar/kalendar-day.vue?vue&type=script&lang=js&","dependencies":[{"path":"/home/david/workspace/kalendar/src/components/kalendar/kalendar-day.vue","mtime":1566976249008},{"path":"/home/david/workspace/kalendar/node_modules/cache-loader/dist/cjs.js","mtime":1564752366860},{"path":"/home/david/workspace/kalendar/node_modules/babel-loader/lib/index.js","mtime":1564752363126},{"path":"/home/david/workspace/kalendar/node_modules/cache-loader/dist/cjs.js","mtime":1564752366860},{"path":"/home/david/workspace/kalendar/node_modules/vue-loader/lib/index.js","mtime":1564752367572}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nconst { cloneObject } = window.kalendarHelpers;\nimport Utils from './utils';\nconst { isToday, isWeekend } = Utils;\n\nimport myWorker from '@/components/kalendar/workers';\n\nexport default {\n  props: ['day', 'passedTime'],\n  created() {\n    // get and render day cells\n    // and then render any event\n    // on top of them\n    this.renderDay();\n  },\n  components: {\n    kalendarCell: () =>\n      import('./kalendar-cell.vue'),\n  },\n  provide() {\n    // provide these methods to children components\n    // for easier access\n    return {\n      kalendarAddEvent: this.addEvent,\n      kalendarClearPopups: this.clearCreatingLeftovers\n    };\n  },\n  // inject kalendar options from parent component\n  inject: ['kalendar_options'],\n  mounted() {\n    if (this.kalendar_options.scrollToNow && this.isToday) this.scrollView();\n  },\n  computed: {\n    isWeekend() {\n      return isWeekend(this.day.value);\n    },\n    isToday() {\n      return isToday(this.day.value);\n    },\n  },\n  data: () => ({\n    // this is the main object\n    // we use to make selections\n    // and control their flows\n    creator: {\n      creating: false,\n      starting_cell: null,\n      original_starting_cell: null,\n      current_cell: null,\n      ending_cell: null,\n      status: null,\n    },\n    // temporary event is an object\n    // that holds values of creator\n    // when the popup is initiated\n    temporary_event: null,\n\n    // day cells and events are used for rendering purposes\n    day_cells: [],\n    day_events: null,\n  }),\n  methods: {\n    renderDay() {\n      myWorker.send('getDayCells', {\n        day: this.day.value,\n        hourOptions: {\n          start_hour: this.kalendar_options.day_starts_at,\n          end_hour: this.kalendar_options.day_ends_at\n        }\n      }).then(reply => {\n        this.day_cells = reply;\n        return this.getDayEvents(this.$kalendar.getEvents());\n      });\n    },\n\n    addEvent(payload) {\n      // validation\n      let validation_message = this.checkEventValidity(payload);\n      if (validation_message !== null) {\n        return Promise.reject(validation_message);\n      }\n\n      // use web worker to generate event\n      // and then render it in the day_events objects\n      let { from, to } = payload;\n      from = kalendarHelpers.getLocaleTime(from);\n      to = kalendarHelpers.getLocaleTime(to);\n      return myWorker.send('constructNewEvent', {\n        event: {\n          ...payload,\n          from,\n          to\n        }\n      }).then(constructed_event => {\n        let { key } = constructed_event;\n        if (this.day_events.hasOwnProperty(key)) {\n          this.day_events[key].push(constructed_event);\n        } else {\n          // must use $set since key wasnt present in the object\n          // vue will fail to render it\n          this.$set(this.day_events, key, [constructed_event]);\n        }\n        let events = this.$kalendar.getEvents();\n        console.log('Adding event to kalendar', payload);\n        events.push({\n          ...payload,\n          id: constructed_event.id\n        });\n        this.$kalendar.updateEvents(events);\n      });\n    },\n\n    // this is not called inside this component\n    // but rather from the kalendar-weekview component\n    // which targets it using $refs object.\n    removeEvent(payload) {\n      let events = this.$kalendar.getEvents();\n      let eventIndex = events.findIndex(event => event.id === payload.id);\n      if (eventIndex < 0) return;\n      events.splice(eventIndex, 1);\n      let index = this.day_events[payload.key]\n        .findIndex(event => event.id === payload.id);\n      this.day_events[payload.key].splice(index, 1);\n      this.$kalendar.updateEvents(events);\n      return Promise.resolve();\n    },\n    checkEventValidity(payload) {\n      let { from, to } = payload;\n      if (!from || !to) return 'No dates were provided in the payload';\n      /*if (isoFrom !== from) {\n        return 'From date is not ISO format';\n      }\n      if (isoTo !== to) {\n        return 'To date is not ISO format';\n      }*/\n      return null;\n    },\n    getDayEvents(events) {\n      let clonedEvents = events.map(event => cloneObject(event));\n      return myWorker.send('constructDayEvents', {\n        events: clonedEvents,\n        day: this.day.value,\n      }).then(constructed_events => {\n        this.day_events = constructed_events;\n      })\n    },\n    clearCreatingLeftovers() {\n      for (let key in this.day_events) {\n        let hasPending = this.day_events[key].some(event => {\n          return event.status === 'popup-initiated' || event.status === 'creating';\n        });\n        if (hasPending) {\n          let completed = this.day_events[key]\n            .filter(event => event.status === 'completed');\n          this.$set(this.day_events, key, completed);\n          if (completed.length === 0) {\n            delete this.day_events[key];\n          }\n        }\n      }\n      this.resetEvents();\n    },\n    resetEvents() {\n      if (!this.creator.creating && this.creator.status === null) return;\n      this.creator = {\n        creating: false,\n        starting_cell: null,\n        original_starting_cell: null,\n        current_cell: null,\n        ending_cell: null,\n        status: null,\n        temporary_id: null\n      };\n      this.temporary_event = null;\n    },\n\n    // this method is what we use\n    // to start the flow of selecting a new cell\n    // while the creator is enabled\n    updateCreator(payload) {\n      this.creator = {\n        ...this.validateSelection(payload),\n        status: 'creating'\n      };\n      if (this.kalendar_options.overlap === false && Object.keys(this.day_events).length > 0) {\n        let fixedOverlap = this.overlapPolice(payload);\n        if (fixedOverlap) {\n          this.creator = this.validateSelection(fixedOverlap);\n          this.selectCell();\n          this.initiatePopup();\n          return;\n        }\n      }\n      this.selectCell();\n    },\n\n    // when the direction is reversed,\n    // the ending cell is actually the originally selected cell\n    validateSelection(event) {\n      let { original_starting_cell, starting_cell, current_cell } = event;\n      if (event.direction === 'reverse' &&\n        original_starting_cell.index > current_cell.index) {\n        return {\n          ...event,\n          starting_cell: current_cell,\n          ending_cell: original_starting_cell\n        }\n      }\n      return event;\n    },\n    selectCell() {\n      if (!this.creator.creating) return;\n      let {\n        creating,\n        ending_cell,\n        current_cell,\n        starting_cell,\n        original_starting_cell\n      } = this.creator;\n\n      let real_ending_cell_index = ending_cell.index + 1;\n      ending_cell = this.day_cells[real_ending_cell_index];\n\n      const diffInMs = new Date(ending_cell.value) - new Date(starting_cell.value);\n      const diffInHrs = Math.floor((diffInMs % 86400000) / 3600000);\n      const diffMins = Math.round(((diffInMs % 86400000) % 3600000) / 60000);\n      let startDate = new Date(starting_cell.value);\n      let endDate = new Date(ending_cell.value);\n\n      let distance = diffMins + (diffInHrs * 60);\n\n      this.temporary_event = {\n        start: {\n          masked_value: startDate.toISOString(),\n          value: startDate.toISOString(),\n          rounded: false,\n          round_offset: null\n        },\n        end: {\n          masked_value: endDate.toISOString(),\n          value: endDate.toISOString(),\n          rounded: false,\n          round_offset: null\n        },\n        distance: distance,\n        status: 'creating'\n      };\n    },\n    initiatePopup() {\n      if (this.creating && this.creator.status !== 'creating') return;\n      this.creator = {\n        ...this.creator,\n        status: 'popup-initiated',\n        creating: false\n      };\n      let { ending_cell, current_cell, starting_cell, original_starting_cell } = this.creator;\n      let real_ending_cell_index = ending_cell.index + 1;\n      ending_cell = this.day_cells[real_ending_cell_index];\n\n      const diffInMs = new Date(ending_cell.value) - new Date(starting_cell.value);\n      const diffInHrs = Math.floor((diffInMs % 86400000) / 3600000);\n      const diffMins = Math.round(((diffInMs % 86400000) % 3600000) / 60000);\n      let startDate = new Date(starting_cell.value);\n      let endDate = new Date(ending_cell.value);\n\n      let finalEvent = {\n        start: {\n          masked_value: startDate.toISOString(),\n          value: startDate.toISOString(),\n          rounded: false,\n          round_offset: null\n        },\n        end: {\n          masked_value: endDate.toISOString(),\n          value: endDate.toISOString(),\n          rounded: false,\n          round_offset: null\n        },\n        distance: diffMins + (diffInHrs * 60),\n        status: 'popup-initiated'\n      };\n\n      let updated_events = this.day_events[starting_cell.value];\n      if (!updated_events) updated_events = [];\n      updated_events.push(finalEvent);\n\n      this.$set(this.day_events, starting_cell.value, updated_events);\n      this.temporary_event = null;\n    },\n    overlapPolice(payload) {\n      if (!payload.current_cell) return;\n      let overlapped = Object.keys(this.day_events)\n        .map(evKey => {\n          return this.day_events[evKey]\n        })\n        .flat()\n        .filter(event => {\n          let cellStart = new Date(payload.starting_cell.value);\n          let cellEnd = new Date(payload.ending_cell.value);\n          let eventStarts = new Date(event.start.value);\n          let eventEnds = new Date(event.end.value);\n          return (cellEnd > eventStarts && cellEnd < eventEnds) ||\n            (cellStart < eventStarts && cellEnd > eventStarts);\n        });\n      if (!overlapped || overlapped.length === 0) {\n        return;\n      }\n      let newPayload = payload;\n      if (payload.direction === 'reverse') {\n        let needed_cell = overlapped[0].end;\n        let event_cell = this.day_cells.find(c => c.value === needed_cell.masked_value);\n        let cell = this.day_cells[event_cell.index];\n        newPayload.starting_cell = {\n          value: cell.value,\n          index: cell.index\n        };\n        newPayload.current_cell = {\n          value: cell.value,\n          index: cell.index\n        };\n      } else {\n        let needed_cell = overlapped[0].start;\n        let event_cell = this.day_cells.find(c => c.value === needed_cell.masked_value);\n        let cell = this.day_cells[event_cell.index - 1];\n        newPayload.ending_cell = {\n          value: cell.value,\n          index: cell.index\n        };\n      }\n      return newPayload;\n    },\n    scrollView() {\n      let topoffset = this.$refs.nowIndicator.offsetTop;\n      console.log('Scrolling to :', topoffset);\n      setTimeout(() => {\n        window.scroll({ top: topoffset, left: 0, behavior: 'smooth' });\n      }, 500);\n    },\n  },\n}\n",{"version":3,"sources":["kalendar-day.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"kalendar-day.vue","sourceRoot":"src/components/kalendar","sourcesContent":["<template>\n  <ul style=\"position: relative;\"\n      :class=\"{\n      'is-weekend': isWeekend, \n      'is-today': isToday,\n      'creating': creator.creating || creator.status === 'popup-initiated'\n    }\"\n      class=\"kalendar-day\"\n      :ref=\"day.value + '-reference'\">\n    <div ref=\"nowIndicator\"\n         :class=\"kalendar_options.style === 'material_design' ? 'hour-indicator-line' : 'hour-indicator-tooltip'\"\n         v-if=\"isToday\"\n         :style=\"`top:${passedTime}px`\">\n      <span class=\"line\"\n            v-show=\"kalendar_options.style === 'material_design'\"></span>\n    </div>\n    <kalendar-cell v-for=\"(cell, index) in day_cells\"\n                   :constructed-events=\"day_events\"\n                   :key=\"`cell-${index}`\"\n                   :creator=\"creator\"\n                   :cell-data=\"cell\"\n                   :index=\"index\"\n                   @select=\"updateCreator\"\n                   @reset=\"resetEvents()\"\n                   @initiatePopup=\"initiatePopup()\"\n                   :temporary-event=\"temporary_event\" />\n  </ul>\n</template>\n<script>\nconst { cloneObject } = window.kalendarHelpers;\nimport Utils from './utils';\nconst { isToday, isWeekend } = Utils;\n\nimport myWorker from '@/components/kalendar/workers';\n\nexport default {\n  props: ['day', 'passedTime'],\n  created() {\n    // get and render day cells\n    // and then render any event\n    // on top of them\n    this.renderDay();\n  },\n  components: {\n    kalendarCell: () =>\n      import('./kalendar-cell.vue'),\n  },\n  provide() {\n    // provide these methods to children components\n    // for easier access\n    return {\n      kalendarAddEvent: this.addEvent,\n      kalendarClearPopups: this.clearCreatingLeftovers\n    };\n  },\n  // inject kalendar options from parent component\n  inject: ['kalendar_options'],\n  mounted() {\n    if (this.kalendar_options.scrollToNow && this.isToday) this.scrollView();\n  },\n  computed: {\n    isWeekend() {\n      return isWeekend(this.day.value);\n    },\n    isToday() {\n      return isToday(this.day.value);\n    },\n  },\n  data: () => ({\n    // this is the main object\n    // we use to make selections\n    // and control their flows\n    creator: {\n      creating: false,\n      starting_cell: null,\n      original_starting_cell: null,\n      current_cell: null,\n      ending_cell: null,\n      status: null,\n    },\n    // temporary event is an object\n    // that holds values of creator\n    // when the popup is initiated\n    temporary_event: null,\n\n    // day cells and events are used for rendering purposes\n    day_cells: [],\n    day_events: null,\n  }),\n  methods: {\n    renderDay() {\n      myWorker.send('getDayCells', {\n        day: this.day.value,\n        hourOptions: {\n          start_hour: this.kalendar_options.day_starts_at,\n          end_hour: this.kalendar_options.day_ends_at\n        }\n      }).then(reply => {\n        this.day_cells = reply;\n        return this.getDayEvents(this.$kalendar.getEvents());\n      });\n    },\n\n    addEvent(payload) {\n      // validation\n      let validation_message = this.checkEventValidity(payload);\n      if (validation_message !== null) {\n        return Promise.reject(validation_message);\n      }\n\n      // use web worker to generate event\n      // and then render it in the day_events objects\n      let { from, to } = payload;\n      from = kalendarHelpers.getLocaleTime(from);\n      to = kalendarHelpers.getLocaleTime(to);\n      return myWorker.send('constructNewEvent', {\n        event: {\n          ...payload,\n          from,\n          to\n        }\n      }).then(constructed_event => {\n        let { key } = constructed_event;\n        if (this.day_events.hasOwnProperty(key)) {\n          this.day_events[key].push(constructed_event);\n        } else {\n          // must use $set since key wasnt present in the object\n          // vue will fail to render it\n          this.$set(this.day_events, key, [constructed_event]);\n        }\n        let events = this.$kalendar.getEvents();\n        console.log('Adding event to kalendar', payload);\n        events.push({\n          ...payload,\n          id: constructed_event.id\n        });\n        this.$kalendar.updateEvents(events);\n      });\n    },\n\n    // this is not called inside this component\n    // but rather from the kalendar-weekview component\n    // which targets it using $refs object.\n    removeEvent(payload) {\n      let events = this.$kalendar.getEvents();\n      let eventIndex = events.findIndex(event => event.id === payload.id);\n      if (eventIndex < 0) return;\n      events.splice(eventIndex, 1);\n      let index = this.day_events[payload.key]\n        .findIndex(event => event.id === payload.id);\n      this.day_events[payload.key].splice(index, 1);\n      this.$kalendar.updateEvents(events);\n      return Promise.resolve();\n    },\n    checkEventValidity(payload) {\n      let { from, to } = payload;\n      if (!from || !to) return 'No dates were provided in the payload';\n      /*if (isoFrom !== from) {\n        return 'From date is not ISO format';\n      }\n      if (isoTo !== to) {\n        return 'To date is not ISO format';\n      }*/\n      return null;\n    },\n    getDayEvents(events) {\n      let clonedEvents = events.map(event => cloneObject(event));\n      return myWorker.send('constructDayEvents', {\n        events: clonedEvents,\n        day: this.day.value,\n      }).then(constructed_events => {\n        this.day_events = constructed_events;\n      })\n    },\n    clearCreatingLeftovers() {\n      for (let key in this.day_events) {\n        let hasPending = this.day_events[key].some(event => {\n          return event.status === 'popup-initiated' || event.status === 'creating';\n        });\n        if (hasPending) {\n          let completed = this.day_events[key]\n            .filter(event => event.status === 'completed');\n          this.$set(this.day_events, key, completed);\n          if (completed.length === 0) {\n            delete this.day_events[key];\n          }\n        }\n      }\n      this.resetEvents();\n    },\n    resetEvents() {\n      if (!this.creator.creating && this.creator.status === null) return;\n      this.creator = {\n        creating: false,\n        starting_cell: null,\n        original_starting_cell: null,\n        current_cell: null,\n        ending_cell: null,\n        status: null,\n        temporary_id: null\n      };\n      this.temporary_event = null;\n    },\n\n    // this method is what we use\n    // to start the flow of selecting a new cell\n    // while the creator is enabled\n    updateCreator(payload) {\n      this.creator = {\n        ...this.validateSelection(payload),\n        status: 'creating'\n      };\n      if (this.kalendar_options.overlap === false && Object.keys(this.day_events).length > 0) {\n        let fixedOverlap = this.overlapPolice(payload);\n        if (fixedOverlap) {\n          this.creator = this.validateSelection(fixedOverlap);\n          this.selectCell();\n          this.initiatePopup();\n          return;\n        }\n      }\n      this.selectCell();\n    },\n\n    // when the direction is reversed,\n    // the ending cell is actually the originally selected cell\n    validateSelection(event) {\n      let { original_starting_cell, starting_cell, current_cell } = event;\n      if (event.direction === 'reverse' &&\n        original_starting_cell.index > current_cell.index) {\n        return {\n          ...event,\n          starting_cell: current_cell,\n          ending_cell: original_starting_cell\n        }\n      }\n      return event;\n    },\n    selectCell() {\n      if (!this.creator.creating) return;\n      let {\n        creating,\n        ending_cell,\n        current_cell,\n        starting_cell,\n        original_starting_cell\n      } = this.creator;\n\n      let real_ending_cell_index = ending_cell.index + 1;\n      ending_cell = this.day_cells[real_ending_cell_index];\n\n      const diffInMs = new Date(ending_cell.value) - new Date(starting_cell.value);\n      const diffInHrs = Math.floor((diffInMs % 86400000) / 3600000);\n      const diffMins = Math.round(((diffInMs % 86400000) % 3600000) / 60000);\n      let startDate = new Date(starting_cell.value);\n      let endDate = new Date(ending_cell.value);\n\n      let distance = diffMins + (diffInHrs * 60);\n\n      this.temporary_event = {\n        start: {\n          masked_value: startDate.toISOString(),\n          value: startDate.toISOString(),\n          rounded: false,\n          round_offset: null\n        },\n        end: {\n          masked_value: endDate.toISOString(),\n          value: endDate.toISOString(),\n          rounded: false,\n          round_offset: null\n        },\n        distance: distance,\n        status: 'creating'\n      };\n    },\n    initiatePopup() {\n      if (this.creating && this.creator.status !== 'creating') return;\n      this.creator = {\n        ...this.creator,\n        status: 'popup-initiated',\n        creating: false\n      };\n      let { ending_cell, current_cell, starting_cell, original_starting_cell } = this.creator;\n      let real_ending_cell_index = ending_cell.index + 1;\n      ending_cell = this.day_cells[real_ending_cell_index];\n\n      const diffInMs = new Date(ending_cell.value) - new Date(starting_cell.value);\n      const diffInHrs = Math.floor((diffInMs % 86400000) / 3600000);\n      const diffMins = Math.round(((diffInMs % 86400000) % 3600000) / 60000);\n      let startDate = new Date(starting_cell.value);\n      let endDate = new Date(ending_cell.value);\n\n      let finalEvent = {\n        start: {\n          masked_value: startDate.toISOString(),\n          value: startDate.toISOString(),\n          rounded: false,\n          round_offset: null\n        },\n        end: {\n          masked_value: endDate.toISOString(),\n          value: endDate.toISOString(),\n          rounded: false,\n          round_offset: null\n        },\n        distance: diffMins + (diffInHrs * 60),\n        status: 'popup-initiated'\n      };\n\n      let updated_events = this.day_events[starting_cell.value];\n      if (!updated_events) updated_events = [];\n      updated_events.push(finalEvent);\n\n      this.$set(this.day_events, starting_cell.value, updated_events);\n      this.temporary_event = null;\n    },\n    overlapPolice(payload) {\n      if (!payload.current_cell) return;\n      let overlapped = Object.keys(this.day_events)\n        .map(evKey => {\n          return this.day_events[evKey]\n        })\n        .flat()\n        .filter(event => {\n          let cellStart = new Date(payload.starting_cell.value);\n          let cellEnd = new Date(payload.ending_cell.value);\n          let eventStarts = new Date(event.start.value);\n          let eventEnds = new Date(event.end.value);\n          return (cellEnd > eventStarts && cellEnd < eventEnds) ||\n            (cellStart < eventStarts && cellEnd > eventStarts);\n        });\n      if (!overlapped || overlapped.length === 0) {\n        return;\n      }\n      let newPayload = payload;\n      if (payload.direction === 'reverse') {\n        let needed_cell = overlapped[0].end;\n        let event_cell = this.day_cells.find(c => c.value === needed_cell.masked_value);\n        let cell = this.day_cells[event_cell.index];\n        newPayload.starting_cell = {\n          value: cell.value,\n          index: cell.index\n        };\n        newPayload.current_cell = {\n          value: cell.value,\n          index: cell.index\n        };\n      } else {\n        let needed_cell = overlapped[0].start;\n        let event_cell = this.day_cells.find(c => c.value === needed_cell.masked_value);\n        let cell = this.day_cells[event_cell.index - 1];\n        newPayload.ending_cell = {\n          value: cell.value,\n          index: cell.index\n        };\n      }\n      return newPayload;\n    },\n    scrollView() {\n      let topoffset = this.$refs.nowIndicator.offsetTop;\n      console.log('Scrolling to :', topoffset);\n      setTimeout(() => {\n        window.scroll({ top: topoffset, left: 0, behavior: 'smooth' });\n      }, 500);\n    },\n  },\n}\n</script>\n<style lang=\"scss\">\nul.kalendar-day {\n  position: relative;\n  background-color: white;\n\n  &.is-weekend {\n    background-color: var(--weekend-color);\n  }\n\n  &.is-today {\n    background-color: var(--current-day-color);\n  }\n\n  .clear {\n    position: absolute;\n    z-index: 1;\n    top: -20px;\n    right: 0;\n    font-size: 10px;\n  }\n\n  &.creating {\n    z-index: 11;\n\n    .created-event {\n      pointer-events: none;\n    }\n  }\n}\n</style>"]}]}